{
  "language": "Solidity",
  "sources": {
    "contracts/DataCoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n\nerror DataCoin__NotEnoughBalance();\n\ncontract DataCoin {\n\tmapping (address => uint) balances;\n\tuint256 private i_tokensToBeMinted;\n\n\n\tconstructor(uint256 tokensToBeMinted) {\n\t\tbalances[tx.origin] = tokensToBeMinted;\n\t\ti_tokensToBeMinted= tokensToBeMinted;\n\t}\n\n\tfunction sendCoin(address receiver, uint amount) public returns(bool sufficient) {\n\t\tif (balances[msg.sender] < amount) {\n\t\t\t\t\t\t// return false;\n\t\trevert DataCoin__NotEnoughBalance();\n\t\t}\n\n\t\tbalances[msg.sender] -= amount;\n\t\tbalances[receiver] += amount;\n\t\treturn true;\n\t}\n\n\tfunction getBalanceInEth(address addr) public view returns(uint){\n\t\treturn getBalance(addr) * 2;\n\t}\n\n\tfunction getBalance(address addr) public view returns(uint) {\n\t\treturn balances[addr];\n\t}\n\n\tfunction getMintedTokenBalance() public view returns(uint256){\n\t\treturn i_tokensToBeMinted;\n\t}\n\n\n}"
    },
    "contracts/filecoin-api-examples/FilecoinMarketConsumer.sol": {
      "content": "pragma solidity ^0.8.0;\n\nimport {MarketAPI} from \"@zondax/filecoin-solidity/contracts/v0.8/MarketAPI.sol\";\nimport {MarketTypes} from \"@zondax/filecoin-solidity/contracts/v0.8/types/MarketTypes.sol\";\n\ncontract FilecoinMarketConsumer {\n    string public dealLabel;\n    uint64 public dealClientActorId;\n    uint64 public dealProviderActorId;\n    bool public isDealActivated;\n    MarketTypes.GetDealDataCommitmentReturn public dealCommitment;\n    MarketTypes.GetDealTermReturn public dealTerm;\n    MarketTypes.GetDealEpochPriceReturn public dealPricePerEpoch;\n    MarketTypes.GetDealClientCollateralReturn public clientCollateral; \n    MarketTypes.GetDealProviderCollateralReturn public providerCollateral;\n    MarketTypes.GetDealActivationReturn public activationStatus;\n\n    function storeAll(uint64 dealId) public {\n        storeDealLabel(dealId);\n        storeDealClient(dealId);\n        storeDealClientProvider(dealId);\n        storeDealCommitment(dealId);\n        storeDealTerm(dealId);\n        storeDealTotalPrice(dealId);\n        storeClientCollateral(dealId);\n        storeProviderCollateral(dealId);\n        storeDealVerificaton(dealId);\n        storeDealActivationStatus(dealId);\n    } \n\n    function storeDealLabel(uint64 dealId) public  {\n        dealLabel = MarketAPI.getDealLabel(MarketTypes.GetDealLabelParams(dealId)).label;\n    }\n\n    function storeDealClient(uint64 dealId) public {\n        dealClientActorId = MarketAPI.getDealClient(MarketTypes.GetDealClientParams(dealId)).client;\n    }\n\n    function storeDealClientProvider(uint64 dealId) public {\n        dealProviderActorId = MarketAPI.getDealProvider(MarketTypes.GetDealProviderParams(dealId)).provider;\n    }\n\n    function storeDealCommitment(uint64 dealId) public {\n        dealCommitment = MarketAPI.getDealDataCommitment(MarketTypes.GetDealDataCommitmentParams(dealId));\n    }\n\n    function storeDealTerm(uint64 dealId) public {\n        dealTerm = MarketAPI.getDealTerm(MarketTypes.GetDealTermParams(dealId));\n    }\n\n    function storeDealTotalPrice(uint64 dealId) public {\n       dealPricePerEpoch = MarketAPI.getDealTotalPrice(MarketTypes.GetDealEpochPriceParams(dealId));\n    }\n\n    function storeClientCollateral(uint64 dealId) public {\n        clientCollateral = MarketAPI.getDealClientCollateral(MarketTypes.GetDealClientCollateralParams(dealId));\n    }\n    \n    function storeProviderCollateral(uint64 dealId) public {\n        providerCollateral = MarketAPI.getDealProviderCollateral(MarketTypes.GetDealProviderCollateralParams(dealId));\n    }\n\n    function storeDealVerificaton(uint64 dealId) public {\n        isDealActivated = MarketAPI.getDealVerified(MarketTypes.GetDealVerifiedParams(dealId)).verified;\n    }\n\n    function storeDealActivationStatus(uint64 dealId) public {\n        activationStatus = MarketAPI.getDealActivation(MarketTypes.GetDealActivationParams(dealId));\n    }\n}"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/MarketAPI.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"./types/MarketTypes.sol\";\nimport \"./cbor/MarketCbor.sol\";\nimport \"./types/CommonTypes.sol\";\nimport \"./utils/Misc.sol\";\nimport \"./utils/Actor.sol\";\n\n/// @title This contract is a proxy to the singleton Storage Market actor (address: f05). Calling one of its methods will result in a cross-actor call being performed.\n/// @author Zondax AG\nlibrary MarketAPI {\n    using AddressCBOR for bytes;\n    using WithdrawBalanceCBOR for MarketTypes.WithdrawBalanceParams;\n    using WithdrawBalanceCBOR for MarketTypes.WithdrawBalanceReturn;\n    using GetBalanceCBOR for MarketTypes.GetBalanceReturn;\n    using GetDealDataCommitmentCBOR for MarketTypes.GetDealDataCommitmentParams;\n    using GetDealDataCommitmentCBOR for MarketTypes.GetDealDataCommitmentReturn;\n    using GetDealClientCBOR for MarketTypes.GetDealClientParams;\n    using GetDealClientCBOR for MarketTypes.GetDealClientReturn;\n    using GetDealProviderCBOR for MarketTypes.GetDealProviderParams;\n    using GetDealProviderCBOR for MarketTypes.GetDealProviderReturn;\n    using GetDealLabelCBOR for MarketTypes.GetDealLabelParams;\n    using GetDealLabelCBOR for MarketTypes.GetDealLabelReturn;\n    using GetDealTermCBOR for MarketTypes.GetDealTermParams;\n    using GetDealTermCBOR for MarketTypes.GetDealTermReturn;\n    using GetDealEpochPriceCBOR for MarketTypes.GetDealEpochPriceParams;\n    using GetDealEpochPriceCBOR for MarketTypes.GetDealEpochPriceReturn;\n    using GetDealClientCollateralCBOR for MarketTypes.GetDealClientCollateralParams;\n    using GetDealClientCollateralCBOR for MarketTypes.GetDealClientCollateralReturn;\n    using GetDealProviderCollateralCBOR for MarketTypes.GetDealProviderCollateralParams;\n    using GetDealProviderCollateralCBOR for MarketTypes.GetDealProviderCollateralReturn;\n    using GetDealVerifiedCBOR for MarketTypes.GetDealVerifiedParams;\n    using GetDealVerifiedCBOR for MarketTypes.GetDealVerifiedReturn;\n    using GetDealActivationCBOR for MarketTypes.GetDealActivationParams;\n    using GetDealActivationCBOR for MarketTypes.GetDealActivationReturn;\n    using PublishStorageDealsCBOR for MarketTypes.PublishStorageDealsParams;\n    using PublishStorageDealsCBOR for MarketTypes.PublishStorageDealsReturn;\n\n    /// @notice Deposits the received value into the balance held in escrow.\n    function addBalance(bytes memory provider_or_client) internal {\n        bytes memory raw_request = provider_or_client.serializeAddress();\n\n        bytes memory raw_response = Actor.call(MarketTypes.AddBalanceMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        Actor.readRespData(raw_response);\n\n        return;\n    }\n\n    /// @notice Attempt to withdraw the specified amount from the balance held in escrow.\n    /// @notice If less than the specified amount is available, yields the entire available balance.\n    function withdrawBalance(MarketTypes.WithdrawBalanceParams memory params) internal returns (MarketTypes.WithdrawBalanceReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MarketTypes.WithdrawBalanceMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.WithdrawBalanceReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the escrow balance and locked amount for an address.\n    function getBalance(bytes memory addr) internal returns (MarketTypes.GetBalanceReturn memory) {\n        bytes memory raw_request = addr.serializeAddress();\n\n        bytes memory raw_response = Actor.call(MarketTypes.GetBalanceMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetBalanceReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the data commitment and size of a deal proposal.\n    /// @notice This will be available after the deal is published (whether or not is is activated) and up until some undefined period after it is terminated.\n    function getDealDataCommitment(\n        MarketTypes.GetDealDataCommitmentParams memory params\n    ) internal returns (MarketTypes.GetDealDataCommitmentReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(\n            MarketTypes.GetDealDataCommitmentMethodNum,\n            MarketTypes.ActorCode,\n            raw_request,\n            Misc.CBOR_CODEC\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealDataCommitmentReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the client of a deal proposal.\n    function getDealClient(MarketTypes.GetDealClientParams memory params) internal returns (MarketTypes.GetDealClientReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MarketTypes.GetDealClientMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealClientReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the provider of a deal proposal.\n    function getDealProvider(MarketTypes.GetDealProviderParams memory params) internal returns (MarketTypes.GetDealProviderReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MarketTypes.GetDealProviderMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealProviderReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the label of a deal proposal.\n    function getDealLabel(MarketTypes.GetDealLabelParams memory params) internal returns (MarketTypes.GetDealLabelReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MarketTypes.GetDealLabelMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealLabelReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the start epoch and duration (in epochs) of a deal proposal.\n    function getDealTerm(MarketTypes.GetDealTermParams memory params) internal returns (MarketTypes.GetDealTermReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MarketTypes.GetDealTermMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealTermReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the per-epoch price of a deal proposal.\n    function getDealTotalPrice(\n        MarketTypes.GetDealEpochPriceParams memory params\n    ) internal returns (MarketTypes.GetDealEpochPriceReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MarketTypes.GetDealEpochPriceMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealEpochPriceReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the client collateral requirement for a deal proposal.\n    function getDealClientCollateral(\n        MarketTypes.GetDealClientCollateralParams memory params\n    ) internal returns (MarketTypes.GetDealClientCollateralReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(\n            MarketTypes.GetDealClientCollateralMethodNum,\n            MarketTypes.ActorCode,\n            raw_request,\n            Misc.CBOR_CODEC\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealClientCollateralReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the provider collateral requirement for a deal proposal.\n    function getDealProviderCollateral(\n        MarketTypes.GetDealProviderCollateralParams memory params\n    ) internal returns (MarketTypes.GetDealProviderCollateralReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(\n            MarketTypes.GetDealProviderCollateralMethodNum,\n            MarketTypes.ActorCode,\n            raw_request,\n            Misc.CBOR_CODEC\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealProviderCollateralReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @return the verified flag for a deal proposal.\n    /// @notice Note that the source of truth for verified allocations and claims is the verified registry actor.\n    function getDealVerified(MarketTypes.GetDealVerifiedParams memory params) internal returns (MarketTypes.GetDealVerifiedReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MarketTypes.GetDealVerifiedMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealVerifiedReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @notice Fetches activation state for a deal.\n    /// @notice This will be available from when the proposal is published until an undefined period after the deal finishes (either normally or by termination).\n    /// @return USR_NOT_FOUND if the deal doesn't exist (yet), or EX_DEAL_EXPIRED if the deal has been removed from state.\n    function getDealActivation(\n        MarketTypes.GetDealActivationParams memory params\n    ) internal returns (MarketTypes.GetDealActivationReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(MarketTypes.GetDealActivationMethodNum, MarketTypes.ActorCode, raw_request, Misc.CBOR_CODEC);\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.GetDealActivationReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n\n    /// @notice Publish a new set of storage deals (not yet included in a sector).\n    function publishStorageDeals(\n        MarketTypes.PublishStorageDealsParams memory params\n    ) internal returns (MarketTypes.PublishStorageDealsReturn memory) {\n        bytes memory raw_request = params.serialize();\n\n        bytes memory raw_response = Actor.call(\n            MarketTypes.PublishStorageDealsMethodNum,\n            MarketTypes.ActorCode,\n            raw_request,\n            Misc.CBOR_CODEC\n        );\n\n        bytes memory result = Actor.readRespData(raw_response);\n\n        MarketTypes.PublishStorageDealsReturn memory response;\n        response.deserialize(result);\n\n        return response;\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/types/MarketTypes.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"../cbor/BigIntCbor.sol\";\nimport \"./CommonTypes.sol\";\n\n/// @title Filecoin market actor types for Solidity.\n/// @author Zondax AG\nlibrary MarketTypes {\n    bytes constant ActorCode = hex\"0005\";\n    uint constant AddBalanceMethodNum = 822473126;\n    uint constant WithdrawBalanceMethodNum = 2280458852;\n    uint constant GetBalanceMethodNum = 726108461;\n    uint constant GetDealDataCommitmentMethodNum = 1157985802;\n    uint constant GetDealClientMethodNum = 128053329;\n    uint constant GetDealProviderMethodNum = 935081690;\n    uint constant GetDealLabelMethodNum = 46363526;\n    uint constant GetDealTermMethodNum = 163777312;\n    uint constant GetDealEpochPriceMethodNum = 4287162428;\n    uint constant GetDealClientCollateralMethodNum = 200567895;\n    uint constant GetDealProviderCollateralMethodNum = 2986712137;\n    uint constant GetDealVerifiedMethodNum = 2627389465;\n    uint constant GetDealActivationMethodNum = 2567238399;\n    uint constant PublishStorageDealsMethodNum = 2236929350;\n\n    struct WithdrawBalanceParams {\n        bytes provider_or_client;\n        BigInt tokenAmount;\n    }\n\n    struct WithdrawBalanceReturn {\n        BigInt amount_withdrawn;\n    }\n\n    struct GetBalanceReturn {\n        BigInt balance;\n        BigInt locked;\n    }\n\n    struct GetDealDataCommitmentParams {\n        uint64 id;\n    }\n\n    struct GetDealDataCommitmentReturn {\n        bytes data;\n        uint64 size;\n    }\n\n    struct GetDealClientParams {\n        uint64 id;\n    }\n\n    struct GetDealClientReturn {\n        uint64 client;\n    }\n\n    struct GetDealProviderParams {\n        uint64 id;\n    }\n\n    struct GetDealProviderReturn {\n        uint64 provider;\n    }\n\n    struct GetDealLabelParams {\n        uint64 id;\n    }\n\n    struct GetDealLabelReturn {\n        string label;\n    }\n\n    struct GetDealTermParams {\n        uint64 id;\n    }\n\n    struct GetDealTermReturn {\n        int64 start;\n        int64 end;\n    }\n\n    struct GetDealEpochPriceParams {\n        uint64 id;\n    }\n\n    struct GetDealEpochPriceReturn {\n        BigInt price_per_epoch;\n    }\n\n    struct GetDealClientCollateralParams {\n        uint64 id;\n    }\n\n    struct GetDealClientCollateralReturn {\n        BigInt collateral;\n    }\n\n    struct GetDealProviderCollateralParams {\n        uint64 id;\n    }\n\n    struct GetDealProviderCollateralReturn {\n        BigInt collateral;\n    }\n\n    struct GetDealVerifiedParams {\n        uint64 id;\n    }\n\n    struct GetDealVerifiedReturn {\n        bool verified;\n    }\n\n    struct GetDealActivationParams {\n        uint64 id;\n    }\n\n    struct GetDealActivationReturn {\n        int64 activated;\n        int64 terminated;\n    }\n\n    struct PublishStorageDealsParams {\n        CommonTypes.ClientDealProposal[] deals;\n    }\n\n    struct PublishStorageDealsReturn {\n        uint64[] ids;\n        bytes valid_deals;\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/utils/Actor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"./Misc.sol\";\n\nlibrary Actor {\n    uint64 constant GAS_LIMIT = 100000000;\n    uint64 constant CALL_ACTOR_PRECOMPILE_ADDR = 0x0e;\n    uint64 constant MAX_RAW_RESPONSE_SIZE = 0x300;\n    uint64 constant READ_ONLY_FLAG = 0x00000001; // https://github.com/filecoin-project/ref-fvm/blob/master/shared/src/sys/mod.rs#L60\n    uint64 constant DEFAULT_FLAG = 0x00000000;\n\n    function call(uint method_num, bytes memory actor_code, bytes memory raw_request, uint64 codec) internal returns (bytes memory) {\n        bytes memory raw_response = new bytes(MAX_RAW_RESPONSE_SIZE);\n\n        uint raw_request_len;\n        uint actor_code_len;\n        uint amount = msg.value;\n\n        assembly {\n            raw_request_len := mload(raw_request)\n            actor_code_len := mload(actor_code)\n\n            let input := mload(0x40)\n            mstore(input, method_num)\n            // value to send\n            mstore(add(input, 0x20), amount)\n            // readonly flag is mandatory for now\n            mstore(add(input, 0x40), DEFAULT_FLAG)\n            // cbor codec is mandatory for now\n            mstore(add(input, 0x60), codec)\n            // params size\n            mstore(add(input, 0x80), raw_request_len)\n            // address size\n            mstore(add(input, 0xa0), actor_code_len)\n            // actual params (copy by slice of 32 bytes)\n            let start_index := 0xc0\n            let offset := 0\n            for {\n                offset := 0x00\n            } lt(offset, raw_request_len) {\n                offset := add(offset, 0x20)\n            } {\n                mstore(add(input, add(start_index, offset)), mload(add(raw_request, add(0x20, offset))))\n            }\n            if mod(raw_request_len, 0x20) {\n                offset := add(sub(offset, 0x20), mod(raw_request_len, 0x20))\n            }\n\n            // actual address (copy by slice of 32 bytes)\n            start_index := add(start_index, offset)\n            offset := 0\n            for {\n                offset := 0x00\n            } lt(offset, actor_code_len) {\n                offset := add(offset, 0x20)\n            } {\n                mstore(add(input, add(start_index, offset)), mload(add(actor_code, add(0x20, offset))))\n            }\n            if mod(actor_code_len, 0x20) {\n                offset := add(sub(offset, 0x20), mod(actor_code_len, 0x20))\n            }\n\n            // FIXME set inputSize according to the input length\n            // delegatecall(gasLimit, to, inputOffset, inputSize, outputOffset, outputSize)\n            if iszero(delegatecall(GAS_LIMIT, CALL_ACTOR_PRECOMPILE_ADDR, input, 0x100, raw_response, MAX_RAW_RESPONSE_SIZE)) {\n                revert(0, 0)\n            }\n        }\n\n        return raw_response;\n    }\n\n    function readRespData(bytes memory raw_response) internal pure returns (bytes memory) {\n        uint256 exit_code = Misc.toUint256(raw_response, 0x00);\n        uint256 size = Misc.toUint256(raw_response, 0x60);\n        require(exit_code == 0, string.concat(\"actor error code \", Strings.toString(exit_code)));\n\n        bytes memory result = new bytes(size);\n        uint src;\n        uint dst;\n        assembly {\n            src := add(raw_response, 0x80)\n            dst := add(result, 0x20)\n        }\n        Misc.copy(src, dst, size);\n\n        return result;\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/utils/Misc.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nlibrary Misc {\n    uint64 constant CBOR_CODEC = 0x71;\n    uint64 constant NONE_CODEC = 0x00;\n\n    function toUint256(bytes32 _bytes) internal pure returns (uint256 value) {\n        return uint256(_bytes);\n    }\n\n    function toInt256(bytes32 _bytes) internal pure returns (int256 value) {\n        return int256(uint256(_bytes));\n    }\n\n    function toUint256(bytes memory _bytes, uint offset) internal pure returns (uint256 value) {\n        assembly {\n            value := mload(add(_bytes, offset))\n        }\n    }\n\n    function toInt256(bytes memory _bytes, uint offset) internal pure returns (int256 value) {\n        return int256(toUint256(_bytes, offset));\n    }\n\n    function toBytes(uint256 x) internal pure returns (bytes memory b) {\n        b = new bytes(32);\n        assembly {\n            mstore(add(b, 32), x)\n        }\n    }\n\n    function toBytes(int256 x) internal pure returns (bytes memory b) {\n        b = new bytes(32);\n        assembly {\n            mstore(add(b, 32), x)\n        }\n    }\n\n    function copy(uint src, uint dest, uint len) internal pure {\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        if (len == 0) return;\n\n        // Copy remaining bytes\n        uint mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/types/CommonTypes.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"../cbor/BigIntCbor.sol\";\n\n/// @title Filecoin actors' common types for Solidity.\n/// @author Zondax AG\nlibrary CommonTypes {\n    enum RegisteredSealProof {\n        StackedDRG2KiBV1,\n        StackedDRG512MiBV1,\n        StackedDRG8MiBV1,\n        StackedDRG32GiBV1,\n        StackedDRG64GiBV1,\n        StackedDRG2KiBV1P1,\n        StackedDRG512MiBV1P1,\n        StackedDRG8MiBV1P1,\n        StackedDRG32GiBV1P1,\n        StackedDRG64GiBV1P1,\n        Invalid\n    }\n\n    enum RegisteredPoStProof {\n        StackedDRGWinning2KiBV1,\n        StackedDRGWinning8MiBV1,\n        StackedDRGWinning512MiBV1,\n        StackedDRGWinning32GiBV1,\n        StackedDRGWinning64GiBV1,\n        StackedDRGWindow2KiBV1,\n        StackedDRGWindow8MiBV1,\n        StackedDRGWindow512MiBV1,\n        StackedDRGWindow32GiBV1,\n        StackedDRGWindow64GiBV1,\n        Invalid\n    }\n\n    enum RegisteredUpdateProof {\n        StackedDRG2KiBV1,\n        StackedDRG8MiBV1,\n        StackedDRG512MiBV1,\n        StackedDRG32GiBV1,\n        StackedDRG64GiBV1,\n        Invalid\n    }\n    enum ExtensionKind {\n        ExtendCommittmentLegacy,\n        ExtendCommittment\n    }\n\n    enum SectorSize {\n        _2KiB,\n        _8MiB,\n        _512MiB,\n        _32GiB,\n        _64GiB\n    }\n\n    struct ValidatedExpirationExtension {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n        int64 new_expiration;\n    }\n\n    struct ExtendExpirationsInner {\n        ValidatedExpirationExtension[] extensions;\n        bytes claims; // FIXME this is a BTreeMap<SectorNumber, (u64, u64)> on rust\n    }\n\n    struct PendingBeneficiaryChange {\n        bytes new_beneficiary;\n        BigInt new_quota;\n        uint64 new_expiration;\n        bool approved_by_beneficiary;\n        bool approved_by_nominee;\n    }\n\n    struct BeneficiaryTerm {\n        BigInt quota;\n        BigInt used_quota;\n        uint64 expiration;\n    }\n\n    struct ActiveBeneficiary {\n        bytes beneficiary;\n        BeneficiaryTerm term;\n    }\n\n    struct RecoveryDeclaration {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n    }\n\n    struct FaultDeclaration {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n    }\n\n    struct TerminationDeclaration {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n    }\n\n    struct SectorClaim {\n        uint64 sector_number;\n        uint64[] maintain_claims;\n        uint64[] drop_claims;\n    }\n\n    struct ExpirationExtension2 {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n        SectorClaim[] sectors_with_claims;\n        int64 new_expiration;\n    }\n\n    struct ExpirationExtension {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n        int64 new_expiration;\n    }\n\n    struct SectorPreCommitInfoInner {\n        RegisteredSealProof seal_proof;\n        uint64 sector_number;\n        bytes sealed_cid;\n        int64 seal_rand_epoch;\n        uint64[] deal_ids;\n        int64 expiration;\n        bytes unsealed_cid;\n    }\n\n    struct SectorPreCommitInfo {\n        RegisteredSealProof seal_proof;\n        uint64 sector_number;\n        bytes sealed_cid;\n        int64 seal_rand_epoch;\n        uint64[] deal_ids;\n        int64 expiration;\n        bytes unsealed_cid;\n    }\n    struct ReplicaUpdateInner {\n        uint64 sector_number;\n        uint64 deadline;\n        uint64 partition;\n        bytes new_sealed_cid;\n        bytes new_unsealed_cid;\n        uint64[] deals;\n        RegisteredUpdateProof update_proof_type;\n        bytes replica_proof;\n    }\n\n    struct ReplicaUpdate {\n        uint64 sector_number;\n        uint64 deadline;\n        uint64 partition;\n        bytes new_sealed_cid;\n        uint64 deals;\n        RegisteredUpdateProof update_proof_type;\n        bytes replica_proof;\n    }\n\n    struct ReplicaUpdate2 {\n        uint64 sector_number;\n        uint64 deadline;\n        uint64 partition;\n        bytes new_sealed_cid;\n        bytes new_unsealed_cid;\n        uint64 deals;\n        RegisteredUpdateProof update_proof_type;\n        bytes replica_proof;\n    }\n\n    struct PoStPartition {\n        uint64 index;\n        int8 skipped;\n    }\n\n    struct PoStProof {\n        RegisteredPoStProof post_proof;\n        bytes proof_bytes;\n    }\n\n    struct VestingFunds {\n        int64 epoch;\n        BigInt amount;\n    }\n    struct SectorDeals {\n        int64 sector_type;\n        int64 sector_expiry;\n        uint64[] deal_ids;\n    }\n\n    struct DealProposal {\n        bytes piece_cid;\n        uint64 piece_size;\n        bool verified_deal;\n        bytes client;\n        bytes provider;\n        string label;\n        int64 start_epoch;\n        int64 end_epoch;\n        BigInt storage_price_per_epoch;\n        BigInt provider_collateral;\n        BigInt client_collateral;\n    }\n\n    struct ClientDealProposal {\n        DealProposal proposal;\n        bytes client_signature;\n    }\n\n    struct SectorDealData {\n        bytes commd;\n    }\n\n    struct CID {\n        uint8 version;\n        uint64 codec;\n        Multihash hash;\n    }\n\n    struct Multihash {\n        uint64 code;\n        uint8 size;\n        bytes digest;\n    }\n\n    struct VerifiedDealInfo {\n        uint64 client;\n        uint64 allocation_id;\n        bytes data;\n        uint64 size;\n    }\n\n    struct SectorDataSpec {\n        uint64[] deal_ids;\n        int64 sector_type;\n    }\n\n    struct FailCode {\n        uint32 idx;\n        uint32 code;\n    }\n\n    struct BatchReturn {\n        // Total successes in batch\n        uint32 success_count;\n        // Failure code and index for each failure in batch\n        FailCode[] fail_codes;\n    }\n\n    struct Claim {\n        // The provider storing the data (from allocation).\n        uint64 provider;\n        // The client which allocated the DataCap (from allocation).\n        uint64 client;\n        // Identifier of the data committed (from allocation).\n        bytes data;\n        // The (padded) size of data (from allocation).\n        uint64 size;\n        // The min period after term_start which the provider must commit to storing data\n        int64 term_min;\n        // The max period after term_start for which provider can earn QA-power for the data\n        int64 term_max;\n        // The epoch at which the (first range of the) piece was committed.\n        int64 term_start;\n        // ID of the provider's sector in which the data is committed.\n        uint64 sector;\n    }\n    struct ClaimTerm {\n        uint64 provider;\n        uint64 claim_id;\n        int64 term_max;\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/cbor/MarketCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"solidity-cborutils/contracts/CBOR.sol\";\n\nimport {MarketTypes} from \"../types/MarketTypes.sol\";\nimport \"./BigIntCbor.sol\";\nimport \"../utils/CborDecode.sol\";\nimport \"../utils/Misc.sol\";\n\n/// @title FIXME\n/// @author Zondax AG\nlibrary WithdrawBalanceCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for BigInt;\n    using BigIntCBOR for bytes;\n\n    function serialize(MarketTypes.WithdrawBalanceParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(2);\n        buf.writeBytes(params.provider_or_client);\n        buf.writeBytes(params.tokenAmount.serializeBigNum());\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.WithdrawBalanceReturn memory ret, bytes memory rawResp) internal pure {\n        bytes memory tmp;\n        uint byteIdx = 0;\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.amount_withdrawn = tmp.deserializeBigNum();\n    }\n}\n\nlibrary AddressCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serializeAddress(bytes memory addr) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeBytes(addr);\n\n        return buf.data();\n    }\n\n    function deserializeAddress(bytes memory ret) internal pure returns (bytes memory) {\n        bytes memory addr;\n        uint byteIdx = 0;\n\n        (addr, byteIdx) = ret.readBytes(byteIdx);\n\n        return addr;\n    }\n}\n\nlibrary GetBalanceCBOR {\n    using CBORDecoder for bytes;\n    using BigIntCBOR for bytes;\n\n    function deserialize(MarketTypes.GetBalanceReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n        bytes memory tmp;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.balance = tmp.deserializeBigNum();\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.locked = tmp.deserializeBigNum();\n    }\n}\n\nlibrary GetDealDataCommitmentCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MarketTypes.GetDealDataCommitmentParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeUInt64(params.id);\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.GetDealDataCommitmentReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n\n        if (len > 0) {\n            (ret.data, byteIdx) = rawResp.readBytes(byteIdx);\n            (ret.size, byteIdx) = rawResp.readUInt64(byteIdx);\n        }\n    }\n}\n\nlibrary GetDealClientCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MarketTypes.GetDealClientParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeUInt64(params.id);\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.GetDealClientReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n\n        (ret.client, byteIdx) = rawResp.readUInt64(byteIdx);\n    }\n}\n\nlibrary GetDealProviderCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MarketTypes.GetDealProviderParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeUInt64(params.id);\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.GetDealProviderReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n\n        (ret.provider, byteIdx) = rawResp.readUInt64(byteIdx);\n    }\n}\n\nlibrary GetDealLabelCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MarketTypes.GetDealLabelParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeUInt64(params.id);\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.GetDealLabelReturn memory ret, bytes memory rawResp) internal pure {\n        string memory label;\n        uint byteIdx = 0;\n\n        (label, byteIdx) = rawResp.readString(byteIdx);\n\n        ret.label = label;\n    }\n}\n\nlibrary GetDealTermCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MarketTypes.GetDealTermParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeUInt64(params.id);\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.GetDealTermReturn memory ret, bytes memory rawResp) internal pure {\n        int64 start;\n        int64 end;\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (start, byteIdx) = rawResp.readInt64(byteIdx);\n        (end, byteIdx) = rawResp.readInt64(byteIdx);\n\n        ret.start = start;\n        ret.end = end;\n    }\n}\n\nlibrary GetDealEpochPriceCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for bytes;\n\n    function serialize(MarketTypes.GetDealEpochPriceParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeUInt64(params.id);\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.GetDealEpochPriceReturn memory ret, bytes memory rawResp) internal pure {\n        bytes memory tmp;\n        uint byteIdx = 0;\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.price_per_epoch = tmp.deserializeBigNum();\n    }\n}\n\nlibrary GetDealClientCollateralCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for bytes;\n\n    function serialize(MarketTypes.GetDealClientCollateralParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeUInt64(params.id);\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.GetDealClientCollateralReturn memory ret, bytes memory rawResp) internal pure {\n        bytes memory tmp;\n        uint byteIdx = 0;\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.collateral = tmp.deserializeBigNum();\n    }\n}\n\nlibrary GetDealProviderCollateralCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for bytes;\n\n    function serialize(MarketTypes.GetDealProviderCollateralParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeUInt64(params.id);\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.GetDealProviderCollateralReturn memory ret, bytes memory rawResp) internal pure {\n        bytes memory tmp;\n        uint byteIdx = 0;\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.collateral = tmp.deserializeBigNum();\n    }\n}\n\nlibrary GetDealVerifiedCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MarketTypes.GetDealVerifiedParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeUInt64(params.id);\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.GetDealVerifiedReturn memory ret, bytes memory rawResp) internal pure {\n        bool verified;\n        uint byteIdx = 0;\n\n        (verified, byteIdx) = rawResp.readBool(byteIdx);\n\n        ret.verified = verified;\n    }\n}\n\nlibrary GetDealActivationCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n\n    function serialize(MarketTypes.GetDealActivationParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.writeUInt64(params.id);\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.GetDealActivationReturn memory ret, bytes memory rawResp) internal pure {\n        int64 activated;\n        int64 terminated;\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (activated, byteIdx) = rawResp.readInt64(byteIdx);\n        (terminated, byteIdx) = rawResp.readInt64(byteIdx);\n\n        ret.activated = activated;\n        ret.terminated = terminated;\n    }\n}\n\nlibrary PublishStorageDealsCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for BigInt;\n\n    function serialize(MarketTypes.PublishStorageDealsParams memory params) internal pure returns (bytes memory) {\n        // FIXME what should the max length be on the buffer?\n        CBOR.CBORBuffer memory buf = CBOR.create(64);\n\n        buf.startFixedArray(1);\n        buf.startFixedArray(uint64(params.deals.length));\n\n        for (uint64 i = 0; i < params.deals.length; i++) {\n            buf.startFixedArray(11);\n\n            buf.writeBytes(params.deals[i].proposal.piece_cid);\n            buf.writeUInt64(params.deals[i].proposal.piece_size);\n            buf.writeBool(params.deals[i].proposal.verified_deal);\n            buf.writeBytes(params.deals[i].proposal.client);\n            buf.writeBytes(params.deals[i].proposal.provider);\n            buf.writeString(params.deals[i].proposal.label);\n            buf.writeInt64(params.deals[i].proposal.start_epoch);\n            buf.writeInt64(params.deals[i].proposal.end_epoch);\n            buf.writeBytes(params.deals[i].proposal.storage_price_per_epoch.serializeBigNum());\n            buf.writeBytes(params.deals[i].proposal.provider_collateral.serializeBigNum());\n            buf.writeBytes(params.deals[i].proposal.client_collateral.serializeBigNum());\n\n            buf.writeBytes(params.deals[i].client_signature);\n        }\n\n        return buf.data();\n    }\n\n    function deserialize(MarketTypes.PublishStorageDealsReturn memory ret, bytes memory rawResp) internal pure {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.ids = new uint64[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (ret.ids[i], byteIdx) = rawResp.readUInt64(byteIdx);\n        }\n\n        (ret.valid_deals, byteIdx) = rawResp.readBytes(byteIdx);\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/cbor/BigIntCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nstruct BigInt {\n    bytes val;\n    bool neg;\n}\n\nlibrary BigIntCBOR {\n    function serializeBigNum(BigInt memory num) internal pure returns (bytes memory) {\n        // TODO improve gas efficiency by using assembly code\n        bytes memory raw = new bytes(num.val.length + 1);\n\n        if (num.neg) {\n            raw[0] = 0x01;\n        }\n\n        uint index = 1;\n        for (uint i = 0; i < num.val.length; i++) {\n            raw[index] = num.val[i];\n            index++;\n        }\n\n        return raw;\n    }\n\n    function deserializeBigNum(bytes memory raw) internal pure returns (BigInt memory) {\n        // TODO improve gas efficiency by using assembly code\n\n        // Is an empty byte a valid BigInt ? We should have the sign byte at least\n        if (raw.length == 0) {\n            return BigInt(hex\"00\", false);\n        }\n\n        bytes memory val = new bytes(raw.length - 1);\n        bool neg = false;\n\n        if (raw[0] == 0x01) {\n            neg = true;\n        }\n\n        for (uint i = 1; i < raw.length; i++) {\n            val[i - 1] = raw[i];\n        }\n\n        return BigInt(val, neg);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/utils/CborDecode.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// DRAFT!! THIS CODE HAS NOT BEEN AUDITED - USE ONLY FOR PROTOTYPING\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\n// \tMajUnsignedInt = 0\n// \tMajSignedInt   = 1\n// \tMajByteString  = 2\n// \tMajTextString  = 3\n// \tMajArray       = 4\n// \tMajMap         = 5\n// \tMajTag         = 6\n// \tMajOther       = 7\n\nuint8 constant MajUnsignedInt = 0;\nuint8 constant MajSignedInt = 1;\nuint8 constant MajByteString = 2;\nuint8 constant MajTextString = 3;\nuint8 constant MajArray = 4;\nuint8 constant MajMap = 5;\nuint8 constant MajTag = 6;\nuint8 constant MajOther = 7;\n\nuint8 constant TagTypeBigNum = 2;\nuint8 constant TagTypeNegativeBigNum = 3;\n\nuint8 constant True_Type = 21;\nuint8 constant False_Type = 20;\n\nlibrary CBORDecoder {\n    function isNullNext(bytes memory cborParams, uint byteIdx) internal pure returns (bool) {\n        return cborParams[byteIdx] == hex\"f6\";\n    }\n\n    function readBool(bytes memory cborParams, uint byteIdx) internal pure returns (bool, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajOther);\n        assert(value == True_Type || value == False_Type);\n\n        return (value != False_Type, byteIdx);\n    }\n\n    function readFixedArray(bytes memory cborParams, uint byteIdx) internal pure returns (uint, uint) {\n        uint8 maj;\n        uint len;\n\n        (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajArray);\n\n        return (len, byteIdx);\n    }\n\n    function readString(bytes memory cborParams, uint byteIdx) internal pure returns (string memory, uint) {\n        uint8 maj;\n        uint len;\n\n        (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajTextString);\n\n        uint max_len = byteIdx + len;\n        bytes memory slice = new bytes(len);\n        uint slice_index = 0;\n        for (uint256 i = byteIdx; i < max_len; i++) {\n            slice[slice_index] = cborParams[i];\n            slice_index++;\n        }\n\n        return (string(slice), byteIdx + len);\n    }\n\n    function readBytes(bytes memory cborParams, uint byteIdx) internal pure returns (bytes memory, uint) {\n        uint8 maj;\n        uint len;\n\n        (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajTag || maj == MajByteString);\n\n        if (maj == MajTag) {\n            (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\n            assert(maj == MajByteString);\n        }\n\n        uint max_len = byteIdx + len;\n        bytes memory slice = new bytes(len);\n        uint slice_index = 0;\n        for (uint256 i = byteIdx; i < max_len; i++) {\n            slice[slice_index] = cborParams[i];\n            slice_index++;\n        }\n\n        return (slice, byteIdx + len);\n    }\n\n    function readBytes32(bytes memory cborParams, uint byteIdx) internal pure returns (bytes32, uint) {\n        uint8 maj;\n        uint len;\n\n        (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajByteString);\n\n        uint max_len = byteIdx + len;\n        bytes memory slice = new bytes(32);\n        uint slice_index = 32 - len;\n        for (uint256 i = byteIdx; i < max_len; i++) {\n            slice[slice_index] = cborParams[i];\n            slice_index++;\n        }\n\n        return (bytes32(slice), byteIdx + len);\n    }\n\n    function readUInt256(bytes memory cborParams, uint byteIdx) internal pure returns (uint256, uint) {\n        uint8 maj;\n        uint256 value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajTag || maj == MajUnsignedInt);\n\n        if (maj == MajTag) {\n            assert(value == TagTypeBigNum);\n\n            uint len;\n            (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\n            assert(maj == MajByteString);\n\n            require(cborParams.length >= byteIdx + len, \"slicing out of range\");\n            assembly {\n                value := mload(add(cborParams, add(len, byteIdx)))\n            }\n\n            return (value, byteIdx + len);\n        }\n\n        return (value, byteIdx);\n    }\n\n    function readInt256(bytes memory cborParams, uint byteIdx) internal pure returns (int256, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajTag || maj == MajSignedInt);\n\n        if (maj == MajTag) {\n            assert(value == TagTypeNegativeBigNum);\n\n            uint len;\n            (maj, len, byteIdx) = parseCborHeader(cborParams, byteIdx);\n            assert(maj == MajByteString);\n\n            require(cborParams.length >= byteIdx + len, \"slicing out of range\");\n            assembly {\n                value := mload(add(cborParams, add(len, byteIdx)))\n            }\n\n            return (int256(value), byteIdx + len);\n        }\n\n        return (int256(value), byteIdx);\n    }\n\n    function readUInt64(bytes memory cborParams, uint byteIdx) internal pure returns (uint64, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajUnsignedInt);\n\n        return (uint64(value), byteIdx);\n    }\n\n    function readUInt32(bytes memory cborParams, uint byteIdx) internal pure returns (uint32, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajUnsignedInt);\n\n        return (uint32(value), byteIdx);\n    }\n\n    function readUInt16(bytes memory cborParams, uint byteIdx) internal pure returns (uint16, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajUnsignedInt);\n\n        return (uint16(value), byteIdx);\n    }\n\n    function readUInt8(bytes memory cborParams, uint byteIdx) internal pure returns (uint8, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajUnsignedInt);\n\n        return (uint8(value), byteIdx);\n    }\n\n    function readInt64(bytes memory cborParams, uint byteIdx) internal pure returns (int64, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajSignedInt || maj == MajUnsignedInt);\n\n        return (int64(uint64(value)), byteIdx);\n    }\n\n    function readInt32(bytes memory cborParams, uint byteIdx) internal pure returns (int32, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajSignedInt || maj == MajUnsignedInt);\n\n        return (int32(uint32(value)), byteIdx);\n    }\n\n    function readInt16(bytes memory cborParams, uint byteIdx) internal pure returns (int16, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajSignedInt || maj == MajUnsignedInt);\n\n        return (int16(uint16(value)), byteIdx);\n    }\n\n    function readInt8(bytes memory cborParams, uint byteIdx) internal pure returns (int8, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborParams, byteIdx);\n        assert(maj == MajSignedInt || maj == MajUnsignedInt);\n\n        return (int8(uint8(value)), byteIdx);\n    }\n\n    function sliceUInt8(bytes memory bs, uint start) internal pure returns (uint8) {\n        require(bs.length >= start + 1, \"slicing out of range\");\n        uint8 x;\n        assembly {\n            x := mload(add(bs, add(0x01, start)))\n        }\n        return x;\n    }\n\n    function sliceUInt16(bytes memory bs, uint start) internal pure returns (uint16) {\n        require(bs.length >= start + 2, \"slicing out of range\");\n        uint16 x;\n        assembly {\n            x := mload(add(bs, add(0x02, start)))\n        }\n        return x;\n    }\n\n    function sliceUInt32(bytes memory bs, uint start) internal pure returns (uint32) {\n        require(bs.length >= start + 4, \"slicing out of range\");\n        uint32 x;\n        assembly {\n            x := mload(add(bs, add(0x04, start)))\n        }\n        return x;\n    }\n\n    function sliceUInt64(bytes memory bs, uint start) internal pure returns (uint64) {\n        require(bs.length >= start + 8, \"slicing out of range\");\n        uint64 x;\n        assembly {\n            x := mload(add(bs, add(0x08, start)))\n        }\n        return x;\n    }\n\n    // Parse cbor header for major type and extra info.\n    // Also return the byte index after moving past header bytes, and the number of bytes consumed\n    function parseCborHeader(bytes memory cbor, uint byteIndex) internal pure returns (uint8, uint64, uint) {\n        uint8 first = sliceUInt8(cbor, byteIndex);\n        byteIndex += 1;\n        uint8 maj = (first & 0xe0) >> 5;\n        uint8 low = first & 0x1f;\n        // We don't handle CBOR headers with extra > 27, i.e. no indefinite lengths\n        assert(low < 28);\n\n        // extra is lower bits\n        if (low < 24) {\n            return (maj, low, byteIndex);\n        }\n\n        // extra in next byte\n        if (low == 24) {\n            uint8 next = sliceUInt8(cbor, byteIndex);\n            byteIndex += 1;\n            assert(next >= 24); // otherwise this is invalid cbor\n            return (maj, next, byteIndex);\n        }\n\n        // extra in next 2 bytes\n        if (low == 25) {\n            uint16 extra16 = sliceUInt16(cbor, byteIndex);\n            byteIndex += 2;\n            return (maj, extra16, byteIndex);\n        }\n\n        // extra in next 4 bytes\n        if (low == 26) {\n            uint32 extra32 = sliceUInt32(cbor, byteIndex);\n            byteIndex += 4;\n            return (maj, extra32, byteIndex);\n        }\n\n        // extra in next 8 bytes\n        assert(low == 27);\n        uint64 extra64 = sliceUInt64(cbor, byteIndex);\n        byteIndex += 8;\n        return (maj, extra64, byteIndex);\n    }\n}\n"
    },
    "solidity-cborutils/contracts/CBOR.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/**\n* @dev A library for populating CBOR encoded payload in Solidity.\n*\n* https://datatracker.ietf.org/doc/html/rfc7049\n*\n* The library offers various write* and start* methods to encode values of different types.\n* The resulted buffer can be obtained with data() method.\n* Encoding of primitive types is staightforward, whereas encoding of sequences can result\n* in an invalid CBOR if start/write/end flow is violated.\n* For the purpose of gas saving, the library does not verify start/write/end flow internally,\n* except for nested start/end pairs.\n*/\n\nlibrary CBOR {\n    using Buffer for Buffer.buffer;\n\n    struct CBORBuffer {\n        Buffer.buffer buf;\n        uint256 depth;\n    }\n\n    uint8 private constant MAJOR_TYPE_INT = 0;\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\n    uint8 private constant MAJOR_TYPE_STRING = 3;\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\n    uint8 private constant MAJOR_TYPE_MAP = 5;\n    uint8 private constant MAJOR_TYPE_TAG = 6;\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n    uint8 private constant TAG_TYPE_BIGNUM = 2;\n    uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n    uint8 private constant CBOR_FALSE = 20;\n    uint8 private constant CBOR_TRUE = 21;\n    uint8 private constant CBOR_NULL = 22;\n    uint8 private constant CBOR_UNDEFINED = 23;\n\n    function create(uint256 capacity) internal pure returns(CBORBuffer memory cbor) {\n        Buffer.init(cbor.buf, capacity);\n        cbor.depth = 0;\n        return cbor;\n    }\n\n    function data(CBORBuffer memory buf) internal pure returns(bytes memory) {\n        require(buf.depth == 0, \"Invalid CBOR\");\n        return buf.buf.buf;\n    }\n\n    function writeUInt256(CBORBuffer memory buf, uint256 value) internal pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n        writeBytes(buf, abi.encode(value));\n    }\n\n    function writeInt256(CBORBuffer memory buf, int256 value) internal pure {\n        if (value < 0) {\n            buf.buf.appendUint8(\n                uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM)\n            );\n            writeBytes(buf, abi.encode(uint256(-1 - value)));\n        } else {\n            writeUInt256(buf, uint256(value));\n        }\n    }\n\n    function writeUInt64(CBORBuffer memory buf, uint64 value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_INT, value);\n    }\n\n    function writeInt64(CBORBuffer memory buf, int64 value) internal pure {\n        if(value >= 0) {\n            writeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n        } else{\n            writeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(-1 - value));\n        }\n    }\n\n    function writeBytes(CBORBuffer memory buf, bytes memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n        buf.buf.append(value);\n    }\n\n    function writeString(CBORBuffer memory buf, string memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n        buf.buf.append(bytes(value));\n    }\n\n    function writeBool(CBORBuffer memory buf, bool value) internal pure {\n        writeContentFree(buf, value ? CBOR_TRUE : CBOR_FALSE);\n    }\n\n    function writeNull(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_NULL);\n    }\n\n    function writeUndefined(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_UNDEFINED);\n    }\n\n    function startArray(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n        buf.depth += 1;\n    }\n\n    function startFixedArray(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_ARRAY, length);\n    }\n\n    function startMap(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n        buf.depth += 1;\n    }\n\n    function startFixedMap(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_MAP, length);\n    }\n\n    function endSequence(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n        buf.depth -= 1;\n    }\n\n    function writeKVString(CBORBuffer memory buf, string memory key, string memory value) internal pure {\n        writeString(buf, key);\n        writeString(buf, value);\n    }\n\n    function writeKVBytes(CBORBuffer memory buf, string memory key, bytes memory value) internal pure {\n        writeString(buf, key);\n        writeBytes(buf, value);\n    }\n\n    function writeKVUInt256(CBORBuffer memory buf, string memory key, uint256 value) internal pure {\n        writeString(buf, key);\n        writeUInt256(buf, value);\n    }\n\n    function writeKVInt256(CBORBuffer memory buf, string memory key, int256 value) internal pure {\n        writeString(buf, key);\n        writeInt256(buf, value);\n    }\n\n    function writeKVUInt64(CBORBuffer memory buf, string memory key, uint64 value) internal pure {\n        writeString(buf, key);\n        writeUInt64(buf, value);\n    }\n\n    function writeKVInt64(CBORBuffer memory buf, string memory key, int64 value) internal pure {\n        writeString(buf, key);\n        writeInt64(buf, value);\n    }\n\n    function writeKVBool(CBORBuffer memory buf, string memory key, bool value) internal pure {\n        writeString(buf, key);\n        writeBool(buf, value);\n    }\n\n    function writeKVNull(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeNull(buf);\n    }\n\n    function writeKVUndefined(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeUndefined(buf);\n    }\n\n    function writeKVMap(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startMap(buf);\n    }\n\n    function writeKVArray(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startArray(buf);\n    }\n\n    function writeFixedNumeric(\n        CBORBuffer memory buf,\n        uint8 major,\n        uint64 value\n    ) private pure {\n        if (value <= 23) {\n            buf.buf.appendUint8(uint8((major << 5) | value));\n        } else if (value <= 0xFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 24));\n            buf.buf.appendInt(value, 1);\n        } else if (value <= 0xFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 25));\n            buf.buf.appendInt(value, 2);\n        } else if (value <= 0xFFFFFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 26));\n            buf.buf.appendInt(value, 4);\n        } else {\n            buf.buf.appendUint8(uint8((major << 5) | 27));\n            buf.buf.appendInt(value, 8);\n        }\n    }\n\n    function writeIndefiniteLengthType(CBORBuffer memory buf, uint8 major)\n        private\n        pure\n    {\n        buf.buf.appendUint8(uint8((major << 5) | 31));\n    }\n\n    function writeDefiniteLengthType(CBORBuffer memory buf, uint8 major, uint64 length)\n        private\n        pure\n    {\n        writeFixedNumeric(buf, major, length);\n    }\n\n    function writeContentFree(CBORBuffer memory buf, uint8 value) private pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_CONTENT_FREE << 5) | value));\n    }\n}"
    },
    "@ensdomains/buffer/contracts/Buffer.sol": {
      "content": "// SPDX-License-Identifier: BSD-2-Clause\npragma solidity ^0.8.4;\n\n/**\n* @dev A library for working with mutable byte buffers in Solidity.\n*\n* Byte buffers are mutable and expandable, and provide a variety of primitives\n* for appending to them. At any time you can fetch a bytes object containing the\n* current contents of the buffer. The bytes object should not be stored between\n* operations, as it may change due to resizing of the buffer.\n*/\nlibrary Buffer {\n    /**\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n    *      a capacity. The capacity may be longer than the current value, in\n    *      which case it can be extended without the need to allocate more memory.\n    */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n    * @dev Initializes a buffer with an initial capacity.\n    * @param buf The buffer to initialize.\n    * @param capacity The number of bytes of space to allocate the buffer.\n    * @return The buffer, for chaining.\n    */\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            let fpm := add(32, add(ptr, capacity))\n            if lt(fpm, ptr) {\n                revert(0, 0)\n            }\n            mstore(0x40, fpm)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Initializes a new buffer from an existing bytes object.\n    *      Changes to the buffer may mutate the original value.\n    * @param b The bytes object to initialize the buffer with.\n    * @return A new buffer.\n    */\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    /**\n    * @dev Sets buffer length to 0.\n    * @param buf The buffer to truncate.\n    * @return The original buffer, for chaining..\n    */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\n        require(len <= data.length);\n\n        uint off = buf.buf.length;\n        uint newCapacity = off + len;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(newCapacity, buflen) {\n                mstore(bufptr, newCapacity)\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return append(buf, data, data.length);\n    }\n\n    /**\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint offPlusOne = off + 1;\n        if (off >= buf.capacity) {\n            resize(buf, offPlusOne * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if gt(offPlusOne, mload(bufptr)) {\n                mstore(bufptr, offPlusOne)\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\n    *      exceed the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to write (left-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        unchecked {\n            uint mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + newCapacity\n                let dest := add(bufptr, newCapacity)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(newCapacity, mload(bufptr)) {\n                    mstore(bufptr, newCapacity)\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chhaining.\n    */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return append(buf, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return append(buf, data, 32);\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     *      exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @param len The number of bytes to write (right-aligned).\n     * @return The original buffer.\n     */\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + newCapacity\n            let dest := add(bufptr, newCapacity)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(newCapacity, mload(bufptr)) {\n                mstore(bufptr, newCapacity)\n            }\n        }\n        return buf;\n    }\n}\n"
    },
    "contracts/filecoin-mock-apis/MockMarketAPI.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"./types/MockMarketTypes.sol\";\n\n/// @title This contract is a proxy to the singleton Storage Market actor (address: f05). Calling one of its methods will result in a cross-actor call being performed. However, in this mock library, no actual call is performed.\n/// @author Zondax AG\n/// @dev Methods prefixed with mock_ will not be available in the real library. These methods are merely used to set mock state. Note that this interface will likely break in the future as we align it\n//       with that of the real library!\ncontract MockMarketAPI {\n    mapping(string => uint256) balances;\n    mapping(uint64 => MarketTypes.MockDeal) deals;\n\n    constructor() {\n        mock_generate_deals();\n    }\n\n    /// @notice Deposits the received value into the balance held in escrow.\n    /// @dev Because this is a mock method, no real balance is being deducted from the caller, nor incremented in the Storage Market actor (f05).\n    function add_balance(\n        MarketTypes.AddBalanceParams memory params\n    ) public payable {\n        balances[params.provider_or_client] += msg.value;\n    }\n\n    /// @notice Attempt to withdraw the specified amount from the balance held in escrow.\n    /// @notice If less than the specified amount is available, yields the entire available balance.\n    /// @dev This method should be called by an approved address, but the mock does not check that the caller is an approved party.\n    /// @dev Because this is a mock method, no real balance is deposited in the designated address, nor decremented from the Storage Market actor (f05).\n    function withdraw_balance(\n        MarketTypes.WithdrawBalanceParams memory params\n    ) public returns (MarketTypes.WithdrawBalanceReturn memory) {\n        uint256 tmp = balances[params.provider_or_client];\n        if (balances[params.provider_or_client] >= params.tokenAmount) {\n            balances[params.provider_or_client] -= params.tokenAmount;\n            tmp = params.tokenAmount;\n        } else {\n            balances[params.provider_or_client] = 0;\n        }\n\n        return MarketTypes.WithdrawBalanceReturn(tmp);\n    }\n\n    /// @return the escrow balance and locked amount for an address.\n    function get_balance(\n        string memory addr\n    ) public view returns (MarketTypes.GetBalanceReturn memory) {\n        uint256 actualBalance = balances[addr];\n\n        return MarketTypes.GetBalanceReturn(actualBalance, 0);\n    }\n\n    /// @return the data commitment and size of a deal proposal.\n    /// @notice This will be available after the deal is published (whether or not is is activated) and up until some undefined period after it is terminated.\n    /// @dev set data values correctly, currently returning fixed data, feel free to adjust in your local mock.\n    function get_deal_data_commitment(\n        MarketTypes.GetDealDataCommitmentParams memory params\n    ) public view returns (MarketTypes.GetDealDataCommitmentReturn memory) {\n        require(deals[params.id].id > 0);\n\n        return\n            MarketTypes.GetDealDataCommitmentReturn(\n                bytes(\"0x111111\"),\n                deals[params.id].size\n            );\n    }\n\n    /// @return the client of a deal proposal.\n    function get_deal_client(\n        MarketTypes.GetDealClientParams memory params\n    ) public view returns (MarketTypes.GetDealClientReturn memory) {\n        require(deals[params.id].id > 0);\n\n        return MarketTypes.GetDealClientReturn(deals[params.id].client);\n    }\n\n    /// @return the provider of a deal proposal.\n    function get_deal_provider(\n        MarketTypes.GetDealProviderParams memory params\n    ) public view returns (MarketTypes.GetDealProviderReturn memory) {\n        require(deals[params.id].id > 0);\n\n        return MarketTypes.GetDealProviderReturn(deals[params.id].provider);\n    }\n\n    /// @return the label of a deal proposal.\n    function get_deal_label(\n        MarketTypes.GetDealLabelParams memory params\n    ) public view returns (MarketTypes.GetDealLabelReturn memory) {\n        require(deals[params.id].id > 0);\n\n        return MarketTypes.GetDealLabelReturn(deals[params.id].label);\n    }\n\n    /// @return the start epoch and duration (in epochs) of a deal proposal.\n    function get_deal_term(\n        MarketTypes.GetDealTermParams memory params\n    ) public view returns (MarketTypes.GetDealTermReturn memory) {\n        require(deals[params.id].id > 0);\n\n        return\n            MarketTypes.GetDealTermReturn(\n                deals[params.id].start,\n                deals[params.id].end\n            );\n    }\n\n    /// @return the per-epoch price of a deal proposal.\n    function get_deal_total_price(\n        MarketTypes.GetDealEpochPriceParams memory params\n    ) public view returns (MarketTypes.GetDealEpochPriceReturn memory) {\n        require(deals[params.id].id > 0);\n\n        return\n            MarketTypes.GetDealEpochPriceReturn(\n                deals[params.id].price_per_epoch\n            );\n    }\n\n    /// @return the client collateral requirement for a deal proposal.\n    function get_deal_client_collateral(\n        MarketTypes.GetDealClientCollateralParams memory params\n    ) public view returns (MarketTypes.GetDealClientCollateralReturn memory) {\n        require(deals[params.id].id > 0);\n\n        return\n            MarketTypes.GetDealClientCollateralReturn(\n                deals[params.id].client_collateral\n            );\n    }\n\n    /// @return the provider collateral requirement for a deal proposal.\n    function get_deal_provider_collateral(\n        MarketTypes.GetDealProviderCollateralParams memory params\n    ) public view returns (MarketTypes.GetDealProviderCollateralReturn memory) {\n        require(deals[params.id].id > 0);\n\n        return\n            MarketTypes.GetDealProviderCollateralReturn(\n                deals[params.id].provider_collateral\n            );\n    }\n\n    /// @return the verified flag for a deal proposal.\n    /// @notice Note that the source of truth for verified allocations and claims is the verified registry actor.\n    function get_deal_verified(\n        MarketTypes.GetDealVerifiedParams memory params\n    ) public view returns (MarketTypes.GetDealVerifiedReturn memory) {\n        require(deals[params.id].id > 0);\n\n        return MarketTypes.GetDealVerifiedReturn(deals[params.id].verified);\n    }\n\n    /// @notice Fetches activation state for a deal.\n    /// @notice This will be available from when the proposal is published until an undefined period after the deal finishes (either normally or by termination).\n    /// @return USR_NOT_FOUND if the deal doesn't exist (yet), or EX_DEAL_EXPIRED if the deal has been removed from state.\n    function get_deal_activation(\n        MarketTypes.GetDealActivationParams memory params\n    ) public view returns (MarketTypes.GetDealActivationReturn memory) {\n        require(deals[params.id].id > 0);\n\n        return\n            MarketTypes.GetDealActivationReturn(\n                deals[params.id].activated,\n                deals[params.id].terminated\n            );\n    }\n\n    /// @notice Publish a new set of storage deals (not yet included in a sector).\n    function publish_storage_deals(bytes memory raw_auth_params, address callee) public {\n        // calls standard filecoin receiver on message authentication api method number\n        (bool success, ) = callee.call(\n            abi.encodeWithSignature(\n                \"handle_filecoin_method(uint64,uint64,bytes)\",\n                0,\n                2643134072,\n                raw_auth_params\n            )\n        );\n        require(success, \"client contract failed to authorize deal publish\");\n    }\n\n    /// @notice Adds mock deal data to the internal state of this mock.\n    /// @dev Feel free to adjust the data here to make it align with deals in your network.\n    function mock_generate_deals() internal {\n        MarketTypes.MockDeal memory deal_67;\n        deal_67.id = 67;\n        deal_67\n            .cid = \"baga6ea4seaqlkg6mss5qs56jqtajg5ycrhpkj2b66cgdkukf2qjmmzz6ayksuci\";\n        deal_67.size = 8388608;\n        deal_67.verified = false;\n        deal_67.client = \"t01109\";\n        deal_67.provider = \"t01113\";\n        deal_67.label = \"mAXCg5AIg8YBXbFjtdBy1iZjpDYAwRSt0elGLF5GvTqulEii1VcM\";\n        deal_67.start = 25245;\n        deal_67.end = 545150;\n        deal_67.price_per_epoch = 1100000000000;\n        deal_67.provider_collateral = 0;\n        deal_67.client_collateral = 0;\n        deal_67.activated = 1;\n        deal_67.terminated = 0;\n\n        deals[deal_67.id] = deal_67;\n\n        // As EVM smart contract has a limited capacity for size (24KiB), we cannot set all deals directly here.\n        // Please, take them from docs.\n\n        // Add or replace more deals here.\n    }\n}\n"
    },
    "contracts/filecoin-mock-apis/types/MockMarketTypes.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\n/// @title Filecoin market actor types for Solidity.\n/// @author Zondax AG\nlibrary MarketTypes {\n    struct MockDeal {\n        uint64 id;\n        string cid;\n        uint64 size;\n        bool verified;\n        string client;\n        string provider;\n        string label;\n        int64 start;\n        int64 end;\n        uint256 price_per_epoch;\n        uint256 provider_collateral;\n        uint256 client_collateral;\n        int64 activated;\n        int64 terminated;\n    }\n\n    struct AddBalanceParams {\n        string provider_or_client;\n    }\n\n    struct WithdrawBalanceParams {\n        string provider_or_client;\n        uint256 tokenAmount;\n    }\n\n    struct WithdrawBalanceReturn {\n        uint256 amount_withdrawn;\n    }\n\n    struct GetBalanceReturn {\n        uint256 balance;\n        uint256 locked;\n    }\n\n    struct GetDealDataCommitmentParams {\n        uint64 id;\n    }\n\n    struct GetDealDataCommitmentReturn {\n        bytes data;\n        uint64 size;\n    }\n\n    struct GetDealClientParams {\n        uint64 id;\n    }\n\n    struct GetDealClientReturn {\n        string client;\n    }\n\n    struct GetDealProviderParams {\n        uint64 id;\n    }\n\n    struct GetDealProviderReturn {\n        string provider;\n    }\n\n    struct GetDealLabelParams {\n        uint64 id;\n    }\n\n    struct GetDealLabelReturn {\n        string label;\n    }\n\n    struct GetDealTermParams {\n        uint64 id;\n    }\n\n    struct GetDealTermReturn {\n        int64 start;\n        int64 end;\n    }\n\n    struct GetDealEpochPriceParams {\n        uint64 id;\n    }\n\n    struct GetDealEpochPriceReturn {\n        uint256 price_per_epoch;\n    }\n\n    struct GetDealClientCollateralParams {\n        uint64 id;\n    }\n\n    struct GetDealClientCollateralReturn {\n        uint256 collateral;\n    }\n\n    struct GetDealProviderCollateralParams {\n        uint64 id;\n    }\n\n    struct GetDealProviderCollateralReturn {\n        uint256 collateral;\n    }\n\n    struct GetDealVerifiedParams {\n        uint64 id;\n    }\n\n    struct GetDealVerifiedReturn {\n        bool verified;\n    }\n\n    struct GetDealActivationParams {\n        uint64 id;\n    }\n\n    struct GetDealActivationReturn {\n        int64 activated;\n        int64 terminated;\n    }\n}\n"
    },
    "contracts/filecoin-mock-apis/MockMinerAPI.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"./types/MockMinerTypes.sol\";\n\n/// @title This contract is a proxy to a built-in Miner actor. Calling one of its methods will result in a cross-actor call being performed. However, in this mock library, no actual call is performed.\n/// @author Zondax AG\n/// @dev Methods prefixed with mock_ will not be available in the real library. These methods are merely used to set mock state. Note that this interface will likely break in the future as we align it\n//       with that of the real library!\ncontract MockMinerAPI {\n    string owner;\n    bool isBeneficiarySet = false;\n    CommonTypes.ActiveBeneficiary activeBeneficiary;\n    mapping(CommonTypes.SectorSize => uint64) sectorSizesBytes;\n\n    /// @notice (Mock method) Sets the owner of a Miner on contract deployment, which will be returned via get_owner().\n    constructor(string memory _owner) {\n        owner = _owner;\n\n        sectorSizesBytes[CommonTypes.SectorSize._2KiB] = 2 << 10;\n        sectorSizesBytes[CommonTypes.SectorSize._8MiB] = 8 << 20;\n        sectorSizesBytes[CommonTypes.SectorSize._512MiB] = 512 << 20;\n        sectorSizesBytes[CommonTypes.SectorSize._32GiB] = 32 << 30;\n        sectorSizesBytes[CommonTypes.SectorSize._64GiB] = 2 * (32 << 30);\n    }\n\n    /// @notice (Mock method) Sets the owner of a Miner, which will be returned via get_owner().\n    function mock_set_owner(string memory addr) public {\n        require(bytes(owner).length == 0);\n        owner = addr;\n    }\n\n    /// @notice Income and returned collateral are paid to this address\n    /// @notice This address is also allowed to change the worker address for the miner\n    /// @return the owner address of a Miner\n    function get_owner()\n        public\n        view\n        returns (MinerTypes.GetOwnerReturn memory)\n    {\n        require(bytes(owner).length != 0);\n\n        return MinerTypes.GetOwnerReturn(owner);\n    }\n\n    /// @param addr New owner address\n    /// @notice Proposes or confirms a change of owner address.\n    /// @notice If invoked by the current owner, proposes a new owner address for confirmation. If the proposed address is the current owner address, revokes any existing proposal that proposed address.\n    function change_owner_address(string memory addr) public {\n        owner = addr;\n    }\n\n    /// @param params The \"controlling\" addresses are the Owner, the Worker, and all Control Addresses.\n    /// @return Whether the provided address is \"controlling\".\n    function is_controlling_address(\n        MinerTypes.IsControllingAddressParam memory params\n    ) public pure returns (MinerTypes.IsControllingAddressReturn memory) {\n        return MinerTypes.IsControllingAddressReturn(false);\n    }\n\n    /// @return the miner's sector size.\n    function get_sector_size()\n        public\n        view\n        returns (MinerTypes.GetSectorSizeReturn memory)\n    {\n        return\n            MinerTypes.GetSectorSizeReturn(\n                sectorSizesBytes[CommonTypes.SectorSize._8MiB]\n            );\n    }\n\n    /// @notice This is calculated as actor balance - (vesting funds + pre-commit deposit + initial pledge requirement + fee debt)\n    /// @notice Can go negative if the miner is in IP debt.\n    /// @return the available balance of this miner.\n    function get_available_balance()\n        public\n        pure\n        returns (MinerTypes.GetAvailableBalanceReturn memory)\n    {\n        return MinerTypes.GetAvailableBalanceReturn(10000000000000000000000);\n    }\n\n    /// @return the funds vesting in this miner as a list of (vesting_epoch, vesting_amount) tuples.\n    function get_vesting_funds()\n        public\n        pure\n        returns (MinerTypes.GetVestingFundsReturn memory)\n    {\n        CommonTypes.VestingFunds[]\n            memory vesting_funds = new CommonTypes.VestingFunds[](1);\n        vesting_funds[0] = CommonTypes.VestingFunds(\n            1668514825,\n            2000000000000000000000\n        );\n\n        return MinerTypes.GetVestingFundsReturn(vesting_funds);\n    }\n\n    /// @notice Proposes or confirms a change of beneficiary address.\n    /// @notice A proposal must be submitted by the owner, and takes effect after approval of both the proposed beneficiary and current beneficiary, if applicable, any current beneficiary that has time and quota remaining.\n    /// @notice See FIP-0029, https://github.com/filecoin-project/FIPs/blob/master/FIPS/fip-0029.md\n    function change_beneficiary(\n        MinerTypes.ChangeBeneficiaryParams memory params\n    ) public {\n        if (!isBeneficiarySet) {\n            CommonTypes.BeneficiaryTerm memory term = CommonTypes\n                .BeneficiaryTerm(params.new_quota, 0, params.new_expiration);\n            activeBeneficiary = CommonTypes.ActiveBeneficiary(\n                params.new_beneficiary,\n                term\n            );\n            isBeneficiarySet = true;\n        } else {\n            activeBeneficiary.beneficiary = params.new_beneficiary;\n            activeBeneficiary.term.quota = params.new_quota;\n            activeBeneficiary.term.expiration = params.new_expiration;\n        }\n    }\n\n    /// @notice This method is for use by other actors (such as those acting as beneficiaries), and to abstract the state representation for clients.\n    /// @notice Retrieves the currently active and proposed beneficiary information.\n    function get_beneficiary()\n        public\n        view\n        returns (MinerTypes.GetBeneficiaryReturn memory)\n    {\n        require(isBeneficiarySet);\n\n        CommonTypes.PendingBeneficiaryChange memory proposed;\n        return MinerTypes.GetBeneficiaryReturn(activeBeneficiary, proposed);\n    }\n}\n"
    },
    "contracts/filecoin-mock-apis/types/MockMinerTypes.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\nimport \"./MockCommonTypes.sol\";\n\n/// @title Filecoin miner actor types for Solidity.\n/// @author Zondax AG\nlibrary MinerTypes {\n    struct GetOwnerReturn {\n        string owner;\n    }\n    struct IsControllingAddressParam {\n        string addr;\n    }\n    struct IsControllingAddressReturn {\n        bool is_controlling;\n    }\n    struct GetSectorSizeReturn {\n        uint64 sector_size;\n    }\n    struct GetAvailableBalanceReturn {\n        int256 available_balance;\n    }\n    struct GetVestingFundsReturn {\n        CommonTypes.VestingFunds[] vesting_funds;\n    }\n\n    struct ChangeBeneficiaryParams {\n        string new_beneficiary;\n        int256 new_quota;\n        uint64 new_expiration;\n    }\n\n    struct GetBeneficiaryReturn {\n        CommonTypes.ActiveBeneficiary active;\n        CommonTypes.PendingBeneficiaryChange proposed;\n    }\n}\n"
    },
    "contracts/filecoin-mock-apis/types/MockCommonTypes.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity >=0.4.25 <=0.8.17;\n\n/// @title Filecoin actors' common types for Solidity.\n/// @author Zondax AG\nlibrary CommonTypes {\n    enum RegisteredSealProof {\n        StackedDRG2KiBV1,\n        StackedDRG512MiBV1,\n        StackedDRG8MiBV1,\n        StackedDRG32GiBV1,\n        StackedDRG64GiBV1,\n        StackedDRG2KiBV1P1,\n        StackedDRG512MiBV1P1,\n        StackedDRG8MiBV1P1,\n        StackedDRG32GiBV1P1,\n        StackedDRG64GiBV1P1,\n        Invalid\n    }\n\n    enum RegisteredPoStProof {\n        StackedDRGWinning2KiBV1,\n        StackedDRGWinning8MiBV1,\n        StackedDRGWinning512MiBV1,\n        StackedDRGWinning32GiBV1,\n        StackedDRGWinning64GiBV1,\n        StackedDRGWindow2KiBV1,\n        StackedDRGWindow8MiBV1,\n        StackedDRGWindow512MiBV1,\n        StackedDRGWindow32GiBV1,\n        StackedDRGWindow64GiBV1,\n        Invalid\n    }\n\n    enum RegisteredUpdateProof {\n        StackedDRG2KiBV1,\n        StackedDRG8MiBV1,\n        StackedDRG512MiBV1,\n        StackedDRG32GiBV1,\n        StackedDRG64GiBV1,\n        Invalid\n    }\n    enum ExtensionKind {\n        ExtendCommittmentLegacy,\n        ExtendCommittment\n    }\n\n    enum SectorSize {\n        _2KiB,\n        _8MiB,\n        _512MiB,\n        _32GiB,\n        _64GiB\n    }\n\n    struct ValidatedExpirationExtension {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n        int64 new_expiration;\n    }\n\n    struct ExtendExpirationsInner {\n        ValidatedExpirationExtension[] extensions;\n        bytes claims; // FIXME this is a BTreeMap<SectorNumber, (u64, u64)> on rust\n    }\n\n    struct PendingBeneficiaryChange {\n        bytes new_beneficiary;\n        int256 new_quota;\n        uint64 new_expiration;\n        bool approved_by_beneficiary;\n        bool approved_by_nominee;\n    }\n\n    struct BeneficiaryTerm {\n        int256 quota;\n        int256 used_quota;\n        uint64 expiration;\n    }\n\n    struct ActiveBeneficiary {\n        string beneficiary;\n        BeneficiaryTerm term;\n    }\n\n    struct RecoveryDeclaration {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n    }\n\n    struct FaultDeclaration {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n    }\n\n    struct TerminationDeclaration {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n    }\n\n    struct SectorClaim {\n        uint64 sector_number;\n        uint64[] maintain_claims;\n        uint64[] drop_claims;\n    }\n\n    struct ExpirationExtension2 {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n        SectorClaim[] sectors_with_claims;\n        int64 new_expiration;\n    }\n\n    struct ExpirationExtension {\n        uint64 deadline;\n        uint64 partition;\n        uint8 sectors;\n        int64 new_expiration;\n    }\n\n    struct FilterEstimate {\n        int256 position;\n        int256 velocity;\n    }\n\n    struct SectorPreCommitInfoInner {\n        RegisteredSealProof seal_proof;\n        uint64 sector_number;\n        bytes sealed_cid;\n        int64 seal_rand_epoch;\n        uint64[] deal_ids;\n        int64 expiration;\n        bytes unsealed_cid;\n    }\n\n    struct SectorPreCommitInfo {\n        RegisteredSealProof seal_proof;\n        uint64 sector_number;\n        bytes sealed_cid;\n        int64 seal_rand_epoch;\n        uint64[] deal_ids;\n        int64 expiration;\n        bytes unsealed_cid;\n    }\n    struct ReplicaUpdateInner {\n        uint64 sector_number;\n        uint64 deadline;\n        uint64 partition;\n        bytes new_sealed_cid;\n        bytes new_unsealed_cid;\n        uint64[] deals;\n        RegisteredUpdateProof update_proof_type;\n        bytes replica_proof;\n    }\n\n    struct ReplicaUpdate {\n        uint64 sector_number;\n        uint64 deadline;\n        uint64 partition;\n        bytes new_sealed_cid;\n        uint64 deals;\n        RegisteredUpdateProof update_proof_type;\n        bytes replica_proof;\n    }\n\n    struct ReplicaUpdate2 {\n        uint64 sector_number;\n        uint64 deadline;\n        uint64 partition;\n        bytes new_sealed_cid;\n        bytes new_unsealed_cid;\n        uint64 deals;\n        RegisteredUpdateProof update_proof_type;\n        bytes replica_proof;\n    }\n\n    struct PoStPartition {\n        uint64 index;\n        int8 skipped;\n    }\n\n    struct PoStProof {\n        RegisteredPoStProof post_proof;\n        bytes proof_bytes;\n    }\n\n    struct VestingFunds {\n        int64 epoch;\n        int256 amount;\n    }\n    struct SectorDeals {\n        int64 sector_type;\n        int64 sector_expiry;\n        uint64[] deal_ids;\n    }\n\n    struct Signature {\n        int8 sig_type;\n        bytes data;\n    }\n\n    struct DealProposal {\n        bytes piece_cid;\n        uint64 piece_size;\n        bool verified_deal;\n        bytes client;\n        bytes provider;\n        string label;\n        int64 start_epoch;\n        int64 end_epoch;\n        int storage_price_per_epoch;\n        int provider_collateral;\n        int client_collateral;\n    }\n\n    struct ClientDealProposal {\n        DealProposal proposal;\n        Signature client_signature;\n    }\n\n    struct SectorDealData {\n        bytes commd;\n    }\n\n    struct CID {\n        uint8 version;\n        uint64 codec;\n        Multihash hash;\n    }\n\n    struct Multihash {\n        uint64 code;\n        uint8 size;\n        bytes digest;\n    }\n\n    struct VerifiedDealInfo {\n        uint64 client;\n        uint64 allocation_id;\n        bytes data;\n        uint64 size;\n    }\n\n    struct SectorDataSpec {\n        uint64[] deal_ids;\n        int64 sector_type;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}